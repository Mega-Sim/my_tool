/** \file
 * \brief Example code for Simple Open EtherCAT master
 *
 * Usage: firm_update ifname1 slave fname
 * ifname is NIC interface, f.e. eth0
 * slave = slave number in EtherCAT order 1..n
 * fname = binary file to store in slave
 * CAUTION! Using the wrong file can result in a bricked slave!
 *
 * This is a slave firmware update test.
 *
 * (c)Arthur Ketels 2011
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <unistd.h>

#include "ethercat.h"

#define VERSION_MAJOR		1
#define VERSION_MINOR		12

#define RESULT_SUCCESS      1
#define RESULT_FAIL			0
// =======================================================================
#define VERSION_DISPLAY_ON      1	
#define FIRM_UPDATE_ON    	1
#define PARAM_UPDATE_ON    	1

// ============ Reading define
#define MAX_DATA 200
#define MAX_COL  6
#define SET_VALUE_SKIP  -1


#define DEF_Name 		0
#define DEF_ParamNo 	1
#define DEF_Index		2
#define DEF_SubIndex	3
#define DEF_DataType	4
#define DEF_SetValue	5

// ============ Data type
// 1byte
#define TYPE_USINT		0
#define TYPE_SINT		1

// 2byte
#define TYPE_UINT		2
#define TYPE_INT		3

// 4byte
#define TYPE_UDINT		4
#define TYPE_DINT		5

// ============ 1 line reading def.
struct line_buf_data {
    char str[MAX_COL][1024];
};

// ============ All line store def.
struct parsing_data {
    char               cName[100];
    char               cParamNo[20];
    unsigned short int ui16_Index;
    unsigned char      ui8_iSubIndex;
    unsigned char      ui8_iDataType;
    int                i_SetValue;
};

struct param_data {
    int iCount;
    struct parsing_data Parsed[MAX_DATA];
};

struct param_data Param_Raw;

// =======================================================================

void remove_spaces(char* s) {
    const char* d = s;
    do {
        // while (*d == ' ') {
        while ((*d == ' ') || (*d == '\n') || (*d == '\r')) {
            ++d;
        }
    } while ((*s++ = *d++));
}

void getfield(char* line, struct line_buf_data* d, int end_idx)
{
    int idx = 0;
    char* token = strtok(line, ",");

    do
    {
        //printf("token: %s\n", token);
        strcpy(d->str[idx++], token);
    } while (idx != end_idx && (token = strtok(NULL, ",")));
}

int parameter_load(char* filename)
{
    FILE* stream = fopen(filename, "r");
    char line[1024];
    struct line_buf_data str_split;
    int iLineCount = 0;

    // -----------------------------------------------------------------
    if (stream == NULL)
    {
        printf("Parameter file not found! Check please! \n");
        return RESULT_FAIL;
    }
	
    printf("### Loaded raw file data.... ### \n");

    while (fgets(line, 1024, stream))
    {
        remove_spaces(line);

        char* tmp = strdup(line);
        getfield(tmp, &str_split, MAX_COL);

        // contents debug print
        for (int i = 0; i < MAX_COL; i++)
        {
        	if (i == 0)
            	printf("[%30s] \t", str_split.str[i]);
			else
				printf("[%7s] \t", str_split.str[i]);
        }
        printf("\n");

        // ############  data convertion ############
        // (1) Name (str)
        strcpy(Param_Raw.Parsed[iLineCount].cName, str_split.str[DEF_Name]);

        // (2) ParamNo (str)
        strcpy(Param_Raw.Parsed[iLineCount].cParamNo, str_split.str[DEF_ParamNo]);

        // (3) Index (Hexa int)
        Param_Raw.Parsed[iLineCount].ui16_Index = (int)strtol(str_split.str[DEF_Index], NULL, 16);

        // (4) SubIndex (int. but if "-" => 0 set)
        if (strcmp("-", str_split.str[DEF_SubIndex]) == 0)
            Param_Raw.Parsed[iLineCount].ui8_iSubIndex = 0;
        else
            Param_Raw.Parsed[iLineCount].ui8_iSubIndex = atoi(str_split.str[DEF_SubIndex]);

        // (5) DataType (int. data byte length (1/2/4) )
        // 1 byte size
        if (strcmp("USINT", str_split.str[DEF_DataType]) == 0)
            Param_Raw.Parsed[iLineCount].ui8_iDataType = TYPE_USINT;   
        else if (strcmp("SINT", str_split.str[DEF_DataType]) == 0)
            Param_Raw.Parsed[iLineCount].ui8_iDataType = TYPE_SINT;      

		// 2 byte size
        else if (strcmp("UINT", str_split.str[DEF_DataType]) == 0)
            Param_Raw.Parsed[iLineCount].ui8_iDataType = TYPE_UINT;   
        else if (strcmp("INT", str_split.str[DEF_DataType]) == 0)
            Param_Raw.Parsed[iLineCount].ui8_iDataType = TYPE_INT; 
		

		// 4 byte size
        else if (strcmp("UDINT", str_split.str[DEF_DataType]) == 0)
            Param_Raw.Parsed[iLineCount].ui8_iDataType = TYPE_UDINT;   
        else if (strcmp("DINT", str_split.str[DEF_DataType]) == 0)
            Param_Raw.Parsed[iLineCount].ui8_iDataType = TYPE_DINT;

		// error
        else
        {
            printf("Sub Index Data : Unknown type error!, check please! \n");
            exit(0);
        }

        // (6) SetValue (int. but if "-" => -1 set)
        if (strcmp("-", str_split.str[DEF_SetValue]) == 0) // 
            Param_Raw.Parsed[iLineCount].i_SetValue = SET_VALUE_SKIP;
        else
            Param_Raw.Parsed[iLineCount].i_SetValue = atoi(str_split.str[DEF_SetValue]);
        // ############################################################

        iLineCount++;
        free(tmp);
    }

    Param_Raw.iCount = iLineCount;

    // -----------------------------------------------------------------
    printf("\n\n### Parsed data.... ### \n");
    printf("[Name(S)]\t\t [ParamNo(S)]\t\t [Index(H)]\t\t [SubIndex(I)]\t\t [DataLength(I)]\t\t [SetVal(I)]\n");
    printf("----------------------------------------------------------------------------------------------------\n");

    for (int i = 0; i < Param_Raw.iCount; i++)
    {
        printf("[%30s]\t", Param_Raw.Parsed[i].cName);
        printf("[%7s]\t", Param_Raw.Parsed[i].cParamNo);
        printf("[0x%04x]\t", Param_Raw.Parsed[i].ui16_Index);
        printf("[%2d]\t", Param_Raw.Parsed[i].ui8_iSubIndex);
        printf("[%2d]\t", Param_Raw.Parsed[i].ui8_iDataType);
        printf("[%2d]\n", Param_Raw.Parsed[i].i_SetValue);
    }

    // -----------------------------------------------------------------
    printf("\n### Data loading OK.. \n\n");

	return RESULT_SUCCESS;
}

// =======================================================================



#define FWBUFSIZE (8 * 1024 * 1024)

uint8 ob;
uint16 ow;
uint32 data;
char filename[256];
char filebuffer[FWBUFSIZE]; // 8MB buffer
int filesize;
int j;
uint16 argslave;

int input_bin(char *fname, int *length)
{
    FILE *fp;

    int cc = 0, c;

    fp = fopen(fname, "rb");

    if(fp == NULL)
        return 0;
    while (((c = fgetc(fp)) != EOF) && (cc < FWBUFSIZE))
		filebuffer[cc++] = (uint8)c;
    *length = cc;
    fclose(fp);
    
    return 1;
}
// -------------------------------------------




// -------------------------------------------

/* 
	return value : 1 - success, 0 - fail
*/
int boottest(char *ifname, uint16 slave, char *filename)
{
    int iResult = 0;
	
	printf("Starting firmware update example\n");

	/* initialise SOEM, bind socket to ifname */
	if (ec_init(ifname))
	{
		printf("ec_init on %s succeeded.\n",ifname);
		/* find and auto-config slaves */


	    if ( ec_config_init(FALSE) > 0 )
		{
			printf("%d slaves found and configured.\n",ec_slavecount);

			/* wait for all slaves to reach PRE_OP state */
			// shkim. windows - linux diff
			ec_statecheck(0, EC_STATE_PRE_OP,  EC_TIMEOUTSTATE * 4);

			printf("Request init state for slave %d\n", slave);
			ec_slave[slave].state = EC_STATE_INIT;
			ec_writestate(slave);

			/* wait for slave to reach INIT state */
			ec_statecheck(slave, EC_STATE_INIT,  EC_TIMEOUTSTATE * 4);
			printf("Slave %d state to INIT.\n", slave);

			/* read BOOT mailbox data, master -> slave */
			data = ec_readeeprom(slave, ECT_SII_BOOTRXMBX, EC_TIMEOUTEEP);
			ec_slave[slave].SM[0].StartAddr = (uint16)LO_WORD(data);
            		ec_slave[slave].SM[0].SMlength = (uint16)HI_WORD(data);
			/* store boot write mailbox address */
			ec_slave[slave].mbx_wo = (uint16)LO_WORD(data);
			/* store boot write mailbox size */
			ec_slave[slave].mbx_l = (uint16)HI_WORD(data);

			/* read BOOT mailbox data, slave -> master */
			data = ec_readeeprom(slave, ECT_SII_BOOTTXMBX, EC_TIMEOUTEEP);
			ec_slave[slave].SM[1].StartAddr = (uint16)LO_WORD(data);
                        ec_slave[slave].SM[1].SMlength = (uint16)HI_WORD(data);
			/* store boot read mailbox address */
			ec_slave[slave].mbx_ro = (uint16)LO_WORD(data);
			/* store boot read mailbox size */
			ec_slave[slave].mbx_rl = (uint16)HI_WORD(data);

			printf(" SM0 A:%4.4x L:%4d F:%8.8x\n", ec_slave[slave].SM[0].StartAddr, ec_slave[slave].SM[0].SMlength,
			    (int)ec_slave[slave].SM[0].SMflags);
			printf(" SM1 A:%4.4x L:%4d F:%8.8x\n", ec_slave[slave].SM[1].StartAddr, ec_slave[slave].SM[1].SMlength,
			    (int)ec_slave[slave].SM[1].SMflags);
			/* program SM0 mailbox in for slave */
			ec_FPWR (ec_slave[slave].configadr, ECT_REG_SM0, sizeof(ec_smt), &ec_slave[slave].SM[0], EC_TIMEOUTRET);
			/* program SM1 mailbox out for slave */
			ec_FPWR (ec_slave[slave].configadr, ECT_REG_SM1, sizeof(ec_smt), &ec_slave[slave].SM[1], EC_TIMEOUTRET);

			printf("Request BOOT state for slave %d\n", slave);
			ec_slave[slave].state = EC_STATE_BOOT;
			ec_writestate(slave);

			/* wait for slave to reach BOOT state */
			if (ec_statecheck(slave, EC_STATE_BOOT,  EC_TIMEOUTSTATE * 10) == EC_STATE_BOOT)
			{
				printf("Slave %d state to BOOT.\n", slave);

				if (input_bin(filename, &filesize))
				{
					printf("File read OK, %d bytes.\n",filesize);
					printf("FoE write....");
					j = ec_FOEwrite(slave, filename, 0x01020304, filesize , &filebuffer, EC_TIMEOUTSTATE);
					printf("result %d.\n",j);

					if(j > 0)
						iResult = RESULT_SUCCESS;	// success
					else
						iResult = RESULT_FAIL;	// fail
					
					printf("Request init state for slave %d\n", slave);
					ec_slave[slave].state = EC_STATE_INIT;
					ec_writestate(slave);
				}
				else
				    printf("File not read OK.\n");
			}

		}
		else
		{
			printf("No slaves found!\n");
		}
		printf("End firmware update example, close socket\n");
		/* stop SOEM, close socket */
		ec_close();
	}
	else
	{
		printf("No socket connection on %s\nExcecute as root\n",ifname);
	}

	return iResult;
}


int readVer(char *ifname, uint16 slave)
{
    int iResult = RESULT_FAIL; // 0 = fail, 1 = success
    
	// ---------- save log
	   FILE *fp;
	   fp = fopen("firm_version.txt", "w");
			
	   if(fp == NULL)
	   {
			printf("Log file open failed... \n");
			return iResult;
	   }
	   else
			printf("Firmware version file open... \n");
	// -------------------------	   

	char fwVer[40];
	int fwLength = sizeof(fwVer) - 1;

	/* initialise SOEM, bind socket to ifname */
	if (ec_init(ifname))
	{
		printf("ec_init on %s succeeded.\n",ifname);
		/* find and auto-config slaves */

		if ( ec_config_init(FALSE) > 0 )
		{
			printf("Request PRE OP state for slave %d\n", slave);
			ec_slave[slave].state = EC_STATE_PRE_OP;
			ec_writestate(slave);

			/* wait for slave to reach INIT state */
			ec_statecheck(slave, EC_STATE_PRE_OP,  EC_TIMEOUTSTATE * 4);
			printf("Slave %d state to PREOP.\n", slave);

			if(ec_statecheck(slave, EC_STATE_PRE_OP, EC_TIMEOUTSTATE * 4) == EC_STATE_PRE_OP){
				ec_SDOread(slave, 0x100A, 0x00, FALSE, &fwLength, fwVer, EC_TIMEOUTRXM);
				printf("F/W Version : %s\n",fwVer);

				if(fp != NULL)
					fprintf(fp, "%s\n", fwVer);

				iResult = RESULT_SUCCESS;
			}
		}
		else
		{
			printf("ec_config_init() func fail!! \n");
		}
	}
	else
	{
		printf("ec_init on %s fail!! \n",ifname);
	}	

	if(fp != NULL)
		fclose(fp);

	return iResult;
}


void param_download_to_motion(uint16 slave)
{
	uint8  		 u_8_int = 0;
	int8   		 s_8_int = 0;
	uint16 		 u_16_int = 0;
    int16  		 s_16_int = 0;
	unsigned int u_32_int = 0;
	int			 s_32_int = 0;

	int          bErrCheck = FALSE;
	int          iErrCount = 0;

	uint8 		u8val[4];

	u8val[0] = 's';
	u8val[1] = 'a';
	u8val[2] = 'v';
	u8val[3] = 'e';
	

	for(int i = 0; i < Param_Raw.iCount; i++)
	{
		switch(Param_Raw.Parsed[i].ui8_iDataType)
		{
		// 1byte
			case TYPE_USINT:
			{
				u_8_int = (uint8)Param_Raw.Parsed[i].i_SetValue;
				ec_SDOwrite(slave, Param_Raw.Parsed[i].ui16_Index, Param_Raw.Parsed[i].ui8_iSubIndex, 
					        FALSE, sizeof(u_8_int), &u_8_int, EC_TIMEOUTRXM);
			}
			break;

			case TYPE_SINT:
			{
				s_8_int = (int8)Param_Raw.Parsed[i].i_SetValue;
				ec_SDOwrite(slave, Param_Raw.Parsed[i].ui16_Index, Param_Raw.Parsed[i].ui8_iSubIndex, 
					        FALSE, sizeof(s_8_int), &s_8_int, EC_TIMEOUTRXM);
			}
			break;
			
		// 2byte
			case TYPE_UINT:
			{
				u_16_int = (uint16)Param_Raw.Parsed[i].i_SetValue;
				ec_SDOwrite(slave, Param_Raw.Parsed[i].ui16_Index, Param_Raw.Parsed[i].ui8_iSubIndex, 
					        FALSE, sizeof(u_16_int), &u_16_int, EC_TIMEOUTRXM);
			}
			break;

			case TYPE_INT:
			{
				s_16_int = (int16)Param_Raw.Parsed[i].i_SetValue;
				ec_SDOwrite(slave, Param_Raw.Parsed[i].ui16_Index, Param_Raw.Parsed[i].ui8_iSubIndex, 
					        FALSE, sizeof(s_16_int), &s_16_int, EC_TIMEOUTRXM);
			}
			break;
			
		// 4byte
			case TYPE_UDINT:
			{
				u_32_int = (unsigned int)Param_Raw.Parsed[i].i_SetValue;
				ec_SDOwrite(slave, Param_Raw.Parsed[i].ui16_Index, Param_Raw.Parsed[i].ui8_iSubIndex, 
					        FALSE, sizeof(u_32_int), &u_32_int, EC_TIMEOUTRXM);
			}
			break;

			case TYPE_DINT:
			{
				s_32_int = (int)Param_Raw.Parsed[i].i_SetValue;
				ec_SDOwrite(slave, Param_Raw.Parsed[i].ui16_Index, Param_Raw.Parsed[i].ui8_iSubIndex, 
					        FALSE, sizeof(s_32_int), &s_32_int, EC_TIMEOUTRXM);
			}
			break;

		// error
			default:
			{
				printf("Unknown data type! check please!. Data Index = %d  Data Type = %d \n", i, Param_Raw.Parsed[i].ui8_iDataType);
				bErrCheck = TRUE;
				iErrCount++;
			}
		}
	}

	if(bErrCheck == FALSE)
	{
		// save parameter value
		ec_SDOwrite(slave, 0x1010, 0x04, FALSE, sizeof(u8val), u8val, EC_TIMEOUTRXM);
		printf("\n Parameter file download OK! \n");
	}
	else
		printf("\n Parameter file downloaded. but Error exist. Count = %d \n", iErrCount);
}

void param_update(char *ifname, uint16 slave)
{
	// uint8 u8val;
	// u8val = 0;  // value set

	/* initialise SOEM, bind socket to ifname */
	if (ec_init(ifname))
	{
		printf("ec_init on %s succeeded.\n",ifname);
		/* find and auto-config slaves */

		if ( ec_config_init(FALSE) > 0 )
		{
			printf("Request PRE OP state for slave %d\n", slave);
			ec_slave[slave].state = EC_STATE_PRE_OP;
			ec_writestate(slave);

			/* wait for slave to reach INIT state */
			ec_statecheck(slave, EC_STATE_PRE_OP,  EC_TIMEOUTSTATE * 4);
			printf("Slave %d state to PREOP.\n", slave);

			if(ec_statecheck(slave, EC_STATE_PRE_OP, EC_TIMEOUTSTATE * 4) == EC_STATE_PRE_OP) {
				
				// ec_SDOwrite(slave, 0x3010, 0x00, FALSE, sizeof(u8val), &u8val, EC_TIMEOUTRXM);
				// ec_SDOwrite(slave, 0x2005, 0x01, FALSE, sizeof(u8val), &u8val, EC_TIMEOUTRXM);
				// printf("Slave %d Reset.\n", slave);
				param_download_to_motion(slave);
				
			}
		}
	}
}

int resettest(char *ifname, uint16 slave)
{
	uint8 u8val;
	u8val = 1;
	int iResult = RESULT_FAIL; // 0 = fail, 1 = success

	/* initialise SOEM, bind socket to ifname */
	if (ec_init(ifname))
	{
		printf("ec_init on %s succeeded.\n",ifname);
		/* find and auto-config slaves */

		if ( ec_config_init(FALSE) > 0 )
		{
			printf("Request PRE OP state for slave %d\n", slave);
			ec_slave[slave].state = EC_STATE_PRE_OP;
			ec_writestate(slave);

			/* wait for slave to reach INIT state */
			ec_statecheck(slave, EC_STATE_PRE_OP,  EC_TIMEOUTSTATE * 4);
			printf("Slave %d state to PREOP.\n", slave);

			if(ec_statecheck(slave, EC_STATE_PRE_OP, EC_TIMEOUTSTATE * 4) == EC_STATE_PRE_OP)
			{
				if(slave == 1)  // Dual moving motion axis
				{
					ec_SDOwrite(slave, 0x2c10, 0x00, FALSE, sizeof(u8val), &u8val, EC_TIMEOUTRXM);
					iResult = RESULT_SUCCESS; // reset success
				}
				else			// Single moving motion
				{
					ec_SDOwrite(slave, 0x3010, 0x00, FALSE, sizeof(u8val), &u8val, EC_TIMEOUTRXM);
					iResult = RESULT_SUCCESS; // reset success
				}
				printf("Slave %d Reset.\n", slave);
			}
		}
	}

	return iResult;
}


void print_usage()
{
    printf("\n\t ########## Pre Setting Step ########## \n");

	printf("\n\t (Step 1) Ecmaster close \n");
	printf(  "\t     (example) \n");
	printf(  "\t       >> ps -ef | grep 'ecmaster' (enter) \n");
    printf(  "\t       >> sudo kill -9 ProcessNo   (enter) \n");

	printf("\n\t (Step 2) Virtual communication port open \n");
	printf(  "\t     (example) \n");
	printf(  "\t       >> echo {} | sudo -S sh -c \"echo 0000:02:00.0 | tee /sys/bus/pci/drivers/igb/bind\" (enter) \n");
	printf(  "\t       >> echo {} | sudo -S sh -c \"echo 0000:03:00.0 | tee /sys/bus/pci/drivers/igb/bind\" (enter) \n");

	
	printf("\n\t ########## Usage info ########## \n");
	printf(  "\t # [Options]                    # \n");
	printf(  "\t #    /v : Version check        # \n");
	printf(  "\t #    /f : Firmware update      # \n");
	printf(  "\t #    /p : Parameter update     # \n");
	printf(  "\t #    /r : Reset Controller     # \n");
	printf("\n\t ################################ \n");
	
	printf("\n\t (1) Firmware version check : sudo ./firm_update /v  network_name  slave_number \n");
	printf(  "\t     (example) \n");
	printf(  "\t       Motion version check => sudo ./firm_update /v enp2s0  1 \n");
	printf(  "\t       Hoist  version check => sudo ./firm_update /v enp2s0  2 \n");
	printf(  "\t       Slide  version check => sudo ./firm_update /v enp2s0  3 \n\n");

	printf("\n\t (2) Run firmware update : sudo ./firm_update /f  network_name  slave_number firmware_name \n");
	printf(  "\t     (example) \n");
	printf(  "\t       sudo ./firm_update /f enp2s0  1 D8N_V_01_01_60_02.bin \n\n");

	printf("\n\t (3) Run parameter update : firm_update /p  network_name  slave_number param_name \n");
	printf(  "\t     (example) \n");
	printf(  "\t       Motion parameter update => sudo ./firm_update /p enp2s0  1 param_driving.txt \n");
	printf(  "\t       Hoist  parameter update => sudo ./firm_update /p enp2s0  2 param_hoist.txt   \n");
	printf(  "\t       Slide  parameter update => sudo ./firm_update /p enp2s0  3 param_slide.txt   \n\n");	

	printf("\n\t (4) Reset motion controller : firm_update /r	network_name  slave_number \n");
	printf(  "\t	 (example) \n");
	printf(  "\t	   Motion controller reset => sudo ./firm_update /r enp2s0	1 \n");
	printf(  "\t	   Hoist  controller reset => sudo ./firm_update /r enp2s0	2 \n");
	printf(  "\t	   Slide  controller reset => sudo ./firm_update /r enp2s0	3 \n\n"); 

}


/*
	argv[0] = running file name
    argv[1] = option
    argv[2] = network
    argv[3] = slave no
    argv[4] = data file name
*/
int main(int argc, char *argv[])
{
    int iResult = RESULT_FAIL; // 0 is fail. 1 is success.
	
    printf("\n>>> SEMES Firmware update utility. Version : %d.%d \n", VERSION_MAJOR, VERSION_MINOR);

	if((argc == 4) || (argc == 5))
	{
		argslave = atoi(argv[3]);

		// if argv[3] is not number, atoi function return value is 0.
		if(argslave == 0)
		{
			printf("Slave no is not number! please check!! \n\n");
			print_usage();
			return -1;
		}
		else
		{
		    printf("Slave no check ok = %d \n", argslave);
			
		}
	}

	if (argc == 4)		// firmware version check & controller reset
	{
		if((strcmp(argv[1], "/v") == 0) || (strcmp(argv[1], "/V") == 0))
		{			
#if VERSION_DISPLAY_ON	
			iResult = readVer(argv[2], argslave);
#else
			printf("version view.... [1]opt=%s [2]net=%s [3]slave=%d \n",
					argv[1], argv[2], argslave);

			// ---------- save log dummy 
			   FILE *fp;
			   fp = fopen("firm_version.txt", "w");
			   if(fp == NULL)
			       printf("Log file open failed... \n");					   
			   else
				   printf("Firmware version file open... \n");		   

			   fprintf(fp, "%s\n", "1.01.60.07");
     		   fclose(fp);

#endif			
		}
		else if((strcmp(argv[1], "/r") == 0) || (strcmp(argv[1], "/R") == 0))
		{
			printf("Controller reset... [1]opt=%s [2]net=%s [3]slave=%d \n",
					argv[1], argv[2], argslave);
			iResult = resettest(argv[2], argslave);

			if(iResult == RESULT_FAIL)
				printf("Controller = %d Reset fail... \n", argslave);
			else
				printf("Controller = %d Reset success! \n", argslave);
		}
		else
		{
			printf("\n Command error(4)! Please check command! \n");
			print_usage();
		}
	}

// =================================================================

	else if (argc == 5)	// firmware update OR parameter update
	{		
		if((strcmp(argv[1], "/f") == 0) || (strcmp(argv[1], "/F") == 0))
		{			
#if FIRM_UPDATE_ON			
			iResult = boottest(argv[2], argslave, argv[4]);
#else
			printf("firmware update.... [1]opt=%s [2]net=%s [3]slave=%d [4]file=%s \n",
					argv[1], argv[2], argslave, argv[4]);
#endif
		}
		else if((strcmp(argv[1], "/p") == 0) || (strcmp(argv[1], "/P") == 0))
		{
		    iResult = parameter_load(argv[4]);	// 0 : fail, 1 : success
			if(iResult == RESULT_FAIL)
			{
				printf("Parameter data file format error. Check please! \n");
				return iResult;
			}
			
#if PARAM_UPDATE_ON			
			param_update(argv[2], argslave);
#else
			printf("param update.... [1]opt=%s [2]net=%s [3]slave=%d [4]file=%s \n",
					argv[1], argv[2], argslave, argv[4]);
#endif
		}
		else
		{
			printf("\n Command error(5)! Please check command! \n");
			print_usage();
		}
	}
	else
	{
		printf("\n Command error(0)! Please check command! \n");
		print_usage();
	}
	

// original code
#if 0
	printf("SOEM (Simple Open EtherCAT Master)\nFirmware update example\n");

	if (argc > 3)
	{
		argslave = atoi(argv[2]);
		boottest(argv[1], argslave, argv[3]);
	}
	else
	{
		printf("Usage: firm_update ifname1 slave fname\n");
		printf("ifname = eth0 for example\n");
		printf("slave = slave number in EtherCAT order 1..n\n");
		printf("fname = binary file to store in slave\n");
		printf("CAUTION! Using the wrong file can result in a bricked slave!\n");
	}

	printf("End program\n");
#endif	
	return (iResult);
}
